## 执行环境和作用域链
### 执行环境
- 执行环境 ---(定义了)---> 变量或函数有权访问的其他数据
- 执行环境 ---(决定了)---> 变量或函数各自的行为
- 每个执行环境 ---(都有一个)---> [与之关联]的**变量对象** <---(保存在)--- 环境中定义的变量和函数
- 最外围的执行环境 —— 全局执行环境（Web 浏览器中是Windows对象）


### 作用域链
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ceea4f5b84945be96d34d03afc7730e~tplv-k3u1fbpfcp-watermark.image)

- 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。
- 当某个函数被调用时，会创建一个执行环（execution context）及相应的作用域链。
- changeColor()的作用域链中只包含两个对象：它自己的**变量对象**和**全局变量对象**。它不能访问swapColors()的环境。

[说明] **函数参数**也被当作变量来对待，其访问规则与执行环境中的其它变量相同。

打个比方，其实作用域链的规则就像水永远只往低处流一样，低处只能接收高处的流下来的水，而高处永远无法接收到低处的水。

### 延长作用域链
- try-catch 语句的 catch 块
- with 语句
这两个语句都会在作用域链的前端添加一个**变量对象**。（临时的）

```Javascript
function getUrl() {
    
    with(location) {
        var url = href + '?'
    }
    return url
}
```
有了`with`关键字，我们可以自由访问其指定对象`location`的属性和方法，因为location对象的属性和方法都被添加到该临时作用域链的变量对象中。


### 没有块级作用域！

``` Javascript
for (var i = 0; i < 5; i++) {
  // do sth
}
console.log(i) // 5
```

学过C、C++、Java的都知道块级作用域，如果像上面的语句在for循环外部是不可能访问到i的，因为执行完for循环它就被销毁了，但是JS它可以！（当然，如果用ES6的let const声明的话就不一样了，这里用的var）。if等语法同理。

1. 声明变量
- 使用 var 声明的变量会自动被添加到最接近的环境中。
- 初始化时没有声明的话变量就自动被添加到全局环境中了。（这是个错误的做法）

2. 查询标识符（变量、...）
- 向上搜索作用域链


## 垃圾收集

- JavaScript 具有**自动垃圾收集机制**：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔**周期性**地执行。
- **垃圾收集器**必须跟踪哪个变量有用/没用，对于不再有用的变量【打上标记】，以备将来收回其占用的内存。通常在浏览器中有两种标识方法：
  1. 标记清除（最常用）
  2. 引用计数
- 全局变量的生命周期 —— 持续到页面卸载才结束
- 关注变量的**可达性**（可访问、可用），可达性保证了变量被保证存储在内存中。（不明白的时候画个图）

### 标记清除
如何标记并不重要（可用任何方式，如翻转某个特殊的位来记录），关键在于采取的策略。

变量进入一个环境时，将这个变量标记为“进入环境”，此时是不能释放其内存的；当变量离开环境时，则将其标记为“离开环境”。

关于垃圾回收这里有篇文章 [谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776) 讲得不错，有兴趣可look look

### 引用计数
现代浏览器使用的都是“标记清除”，引用计数是最初的做法，通过跟踪记录每个值被引用的次数进行标记，其严重的缺陷是不能解决**循环引用**的问题。

### 内存泄漏
即不再有用的内存由于某种原因导致其内存无法释放。下列情况应特别注意：
- 全局变量（未声明）
- 定时器
- 闭包
- DOM元素的引用

```Javascript
// 全局变量（未声明）
function func () {
  value = 1
}
func()
console.log(value)

// 全局变量（this）
function fn () {
  this.val = 1
}
fn()
console.log(this.val)

// DOM元素的引用，尽管移除了元素，ele还是保存了对元素的引用
let ele = document.getElementById('test')
ele.innerHTML = 'hello'
function removeEle () {
  document.body.removeChild(ele)
}
<!-- removeEle() -->
setTimeout(() => console.log(ele), 1000)
```


### 内存管理 —— 解除引用
一旦数据不再有用，最好通过将其值设置为 `null` 来释放其引用 —— 解除引用，适用于全局变量和全局对象的属性（局部变量会在函数调用结束时自动释放内存）。

[注意] 解除引用不意味着自动回收了内存，而是让值脱离执行环境，以便垃圾收集器在下次执行时将其回收！