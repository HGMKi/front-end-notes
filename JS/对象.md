## 计算属性
```
let key = 'name'
let person = {
  [key]: 'LiLy'
}
console.log(person.name) // 'LiLy'
```

- anyWay, 方括号比点符号更强大些，可以在里面使用表达式，也可以使用带有空格或以数字开头或包含特殊字符的变量标识符。


## 属性命名限制
虽然变量不可以以保留字等命名，但是对象属性的命名是ok的。，如 “for”、“let”、“return” ...

But...

但是名为“__proto__”的属性只能是对象，否则
```
let obj = {};
obj.__proto__ = 333
alert(obj.__proto__) // [object Object],把它赋值为数字333的操作被忽略辽
```
!! 属性名可以是任何**字符串**或者**symbol**

```
let obj = {
  0: "hello" // 即"0": "hello"
}
```

## 属性是否存在
```
'name' in obj
// not good
obj.name === undefined // 有可能属性名存在但是值为undefined
```

## 属性遍历
```
for..in
```
值得关注的是遍历结果的顺序：
- 整数属性的升序排序
- 剩余的按创建顺序排序

> 整数属性：Number(num)转换后的结果与num一致

```
Number(+999) // 999, 与+999不一致
Number(1.1) // 1, 与1.1不一致
```
## 对象拷贝
- 拷贝一个对象变量会又创建一个对相同对象的**引用**
- 拷贝对象, 假设对象的所有属性均为原始类型，实质是浅拷贝
  1. **Object.assign**: 只是在根属性(对象的第一层级)创建了一个新的对象, 若属性的值是对象的话只会拷贝一份相同的内存地址
  2. **扩展运算符**：方便，与Object.assign存在相同的问题
  3. **Array.prototype.slice**
  4. **Array.prototype.concat**
  5. **for...in...** 一层循环
- 深拷贝
  
  [ 聊聊对象深拷贝和浅拷贝 -- 掘金](https://juejin.im/post/6844903749270372365#heading-4)
